#  This code is a part of XMM: Generate and Analyse (XGA), a module designed for the XMM Cluster Survey (XCS).
#  Last modified by David J Turner (david.turner@sussex.ac.uk) 15/06/2020, 15:37. Copyright (c) David J Turner

# This XSPEC script template requires quite a few parameters to be filled in, using the Python formatting
#  syntax. This *should* act as a general script for model combinations, so long as the formatted
#  parameter values are valid.

# This loads the XGA custom readout script, used to save fit results, spectra information,
#  and plotting data to a fits file

# As this script is designed to be populated by a Python script, the single curly braces denote places for the Python
#  .format command to inject a value, and every normal TCL use of curly braces has to be double curly braces

#############################################
# Sourcing external TCL files
#############################################
# The TCl file containing the function that extracts and writes out the final results
source {xsp}

# The TCL file containing routines to pre-check spectra before they are simultaneously fit
source {xpc}
#############################################


#############################################
# Setting up XSPEC
#############################################
# Set the statistic type to Cash
statistic cstat

# Allow the user to select the abundance table to use
abund {ab}

# The user can also decide which fitting method to use
method {md}

# The source object cosmology is used to setup XSPEC cosmo
cosmo {H0} {q0} {lamb0}

# We want plotting data to be in terms of energies, not channels
setplot energy
#############################################


#############################################
# Python supplied variables
#############################################
# Set up a list of paths to the spectra we want to fit, done like this to make it more dynamic
set spec_paths {sp}

# The energy limits applied to the spectra before fitting
set ignore_lo_en {lo_cut}
set ignore_hi_en {hi_cut}

# This sets whether the fit should run a check on the spectra before doing the global fit
set run_pre_check {check}
set check_pars {cps}
set check_pars_lo_lim {cpsl}
set check_pars_hi_lim {cpsh}
set check_pars_err_lim {cpse}

# The name of the model
set model_name {m}

# Need the user's parameter choices, initially in the form of a name list and a value list, then an array
#  Also have lists that define whether a parameter in the model will be linked across different spectra, and whether
#  a parameter is frozen during fitting
set par_names {pn}
set par_values {pv}
set linking {lk}
set freezing {fr}

# The confidence interval for parameter error estimation, I don't quite know what the parameter corresponds to,
#  but the tutorials say that 2.706 is equivalent to the 90% confidence region, 9.0 is equivalent to the 3 sigma
#  range, and 1.0 is equivelant to 1sigma
set par_err_interval {el}

# Now the parameters that xga_extract needs
set out_file {of}
set input_redshift {redshift}
set luminosity_confidence {lel}

# This is where the lower and upper energy limits for the luminosity calculations go, xga_extract needs them
set lum_low_lims {lll}
set lum_upp_lims {lul}
#############################################


# Here we run a pre-check to see which of the spectra are good enough to actually contribute anything to the fit
#############################################
# Running the spectral gauntlet
#############################################

#############################################


#############################################
# Loading in Spectra for the final fit
#############################################

# Now put the number of spectra in a variable
set num_spec [llength $spec_paths]

# For loop here to load in all the spectra, iterating over path list
set counter 1
foreach p $spec_paths {{
    # Loads each spectrum into its own data and plot group
    data $counter:$counter $p
    incr counter
    }}

# Now we ignore the energy range that we don't want to use, for all loaded spectra
ignore **:**-$ignore_lo_en **:$ignore_hi_en-**

# If any channels have been labelled bad, this will discount them from analysis
ignore bad
#############################################

# Now we must define the model, but without setting any parameters (thats what /* does)
model $model_name
/*

# Get the number of parameters in a variable, for iterating through later
set num_pars [tcloutr modpar]
# This sets the number of unique parameters for THE MODEL, whereas num_pars is for the model*number of spectra
set num_uniq_par [expr {{$num_pars / $num_spec}}]

# Probably isn't necessary as the inputs should be governed by XGA, but doing some checks
if {{[llength $par_names] != $num_uniq_par}} {{
    puts "par_names list is not the length expected by the defined model"
    exit
}} elseif {{[llength $par_values] != $num_uniq_par}} {{
    puts "par_values list is not the length expected by the defined model"
    exit
}} elseif {{[llength $linking] != $num_uniq_par}} {{
    puts "linking list is not the length expected by the defined model"
    exit
}} elseif {{[llength $freezing] != $num_uniq_par}} {{
    puts "freezing list is not the length expected by the defined model"
    exit
}}

# Just combines them into an array, so we can pass a parameter name and get a value, link bool, and freeze bool
array set par_arr {{}}
array set link_arr {{}}
array set freeze_arr {{}}
for {{set i 0}} {{$i < [llength $par_names]}} {{incr i}} {{
    set temp_key [lindex $par_names $i]
    set temp_contents [array get par_arr]

    # This while loop deals with duplicate keys (which might occur in a two temperature model for instance)
    set key_count 1
    while {{$temp_key in $temp_contents}} {{
        set temp_key [concat [lindex $par_names $i]_$key_count]
        incr key_count
        }}

    set par_arr($temp_key) [lindex $par_values $i]
    set link_arr($temp_key) [lindex $linking $i]
    set freeze_arr($temp_key) [lindex $freezing $i]
    }}


# Here we iterate through the parameters and set them up in XSPEC, including user choices on linking and freezing
set sep_cnt 1
set sep_par_lst {{}}
for {{set i 1}} {{$i <= $num_pars}} {{incr i}} {{
    set cur_par [lindex [tcloutr pinfo $i] 0]

    if {{$sep_cnt <= $num_uniq_par}} {{
        # This while loop deals with duplicate keys (which might occur in a two temperature model for instance)
        set key_count 1
        while {{$cur_par in $sep_par_lst}} {{
            set cur_par [concat [lindex [tcloutr pinfo $i] 0]_$key_count]
            incr key_count
            }}
        lappend sep_par_lst $cur_par
    }} else {{
        puts $sep_par_lst
        set sep_cnt 1
        set sep_par_lst {{$cur_par}}
    }}

    if {{$i <= $num_uniq_par}} {{
        newpar $i $par_arr($cur_par)
    }} elseif {{$i > $num_uniq_par && $link_arr($cur_par) == "F"}} {{
        newpar $i $par_arr($cur_par)
        }}

    if {{$freeze_arr($cur_par) == "T"}} {{
        freeze $i
    }} else {{
        thaw $i
        }}

    incr sep_cnt
    }}

# Now of course we run the model fit
fit 100

# Calculate errors on the fit parameters; error just ignores those parameters that are frozen
error $par_err_interval,1-$num_pars

set lum_lim_pairs {{}}
for {{set i 0}} {{$i < [llength $lum_low_lims]}} {{incr i}} {{
    set interim {{}}
    lappend interim [lindex $lum_low_lims $i]
    lappend interim [lindex $lum_upp_lims $i]
    lappend lum_lim_pairs $interim
    }}

# And finally we run the custom XGA script that extracts all the information we want
xga_extract $out_file $lum_lim_pairs $input_redshift $luminosity_confidence $model_name

exit